<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="https://file.ckx.ink/upload/2020/04/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://file.ckx.ink/upload/2020/04/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://file.ckx.ink/upload/2020/04/favicon-16x16.png">
  <link rel="mask-icon" href="https://file.ckx.ink/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css">
  <script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.ckx.ink","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JVM内存结构">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存结构">
<meta property="og:url" content="https://blog.ckx.ink/2021/10/08/201738.html">
<meta property="og:site_name" content="开心">
<meta property="og:description" content="JVM内存结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/11/up-6d8ce51d2963355c8d8cb86962b08cd7d12-ec27f2ce0a9c4cc0bcb5059590944d49.png">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/12/image-b29fd55537cc48c591df6f6d9127a1fa.png">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/12/image-8307b672a03d4a92bc175ab6163b4b90.png">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/12/image-f73e3ecec3e440269e84ab71abe8f69b.png">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/12/image-e3cdc70cf8734cbdabae985ab933780a.png">
<meta property="og:image" content="https://file.ckx.ink/upload/2021/12/image-029d13727a7c4d159b84030dd495c209.png">
<meta property="article:published_time" content="2021-10-08T12:17:38.000Z">
<meta property="article:modified_time" content="2023-12-07T09:29:25.202Z">
<meta property="article:author" content="开心">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://file.ckx.ink/upload/2021/11/up-6d8ce51d2963355c8d8cb86962b08cd7d12-ec27f2ce0a9c4cc0bcb5059590944d49.png">


<link rel="canonical" href="https://blog.ckx.ink/2021/10/08/201738.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.ckx.ink/2021/10/08/201738.html","path":"2021/10/08/201738.html","title":"JVM内存结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM内存结构 | 开心</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">开心</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">盛年不重来，一日难再晨。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-reader"><a href="https://reader.ckx.ink/" rel="section" target="_blank"><i class="fa fa-book fa-fw"></i>reader</a></li><li class="menu-item menu-item-openai"><a href="https://openai.ckx.ink/" rel="section" target="_blank"><i class="fa fa-robot fa-fw"></i>openai</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="nav-number">1.1.</span> <span class="nav-text">栈的存储单位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">栈的运行原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">栈帧的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.3.3.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">1.3.4.</span> <span class="nav-text">方法返回地址</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.5.</span> <span class="nav-text">附加信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">本地方法栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">为什么要使用本地方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PC-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E5%82%A8%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">使用 PC 寄存器存储字节码指令地址有什么用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PC-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A2%AB%E8%AE%BE%E5%AE%9A%E4%B8%BA%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84"><span class="nav-number">3.3.</span> <span class="nav-text">PC 寄存器为什么会被设定为线程私有的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">堆内存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="nav-number">4.1.</span> <span class="nav-text">内存划分</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="nav-number">4.1.1.</span> <span class="nav-text">年轻代（Young Generation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="nav-number">4.1.2.</span> <span class="nav-text">老年代（Old Generation）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="nav-number">4.1.3.</span> <span class="nav-text">元空间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">设置堆内存的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">4.2.1.</span> <span class="nav-text">查看堆内存分配</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">4.3.</span> <span class="nav-text">垃圾回收简介</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.3.1.</span> <span class="nav-text">Full GC 的触发条件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLAB"><span class="nav-number">4.4.</span> <span class="nav-text">TLAB</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-TLAB"><span class="nav-number">4.4.1.</span> <span class="nav-text">为什么要有 TLAB ?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">5.1.1.</span> <span class="nav-text">类型信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%9F%EF%BC%88Field%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="nav-number">5.1.2.</span> <span class="nav-text">域（Field）信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89%E4%BF%A1%E6%81%AF"><span class="nav-number">5.1.3.</span> <span class="nav-text">方法（Method）信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.4.</span> <span class="nav-text">栈、堆、方法区的交互关系</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">5.2.</span> <span class="nav-text">运行时常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">5.2.1.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">5.2.2.</span> <span class="nav-text">为什么需要常量池</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9C%A8-JDK-%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-number">5.3.</span> <span class="nav-text">方法区在 JDK 中的演进细节</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="开心"
      src="https://file.ckx.ink/upload/2020/04/android-chrome-512x512.png">
  <p class="site-author-name" itemprop="name">开心</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chenkaixin12121" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenkaixin12121" rel="noopener me" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chenkaixin12121@163.com" title="E-Mail → mailto:chenkaixin12121@163.com" rel="noopener me" target="_blank">E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://dev-james.xyz/" title="https:&#x2F;&#x2F;dev-james.xyz" rel="noopener" target="_blank">James Blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://blog.levnli.cn/" title="https:&#x2F;&#x2F;blog.levnli.cn" rel="noopener" target="_blank">木子李</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://huangdf.xyz/" title="https:&#x2F;&#x2F;huangdf.xyz&#x2F;" rel="noopener" target="_blank">柒月是ni的谎言</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    相关文章
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/2021/10/18/184553.html" rel="bookmark">
        <time class="popular-posts-time">2021-10-18</time>
        <br>
      JVM类加载机制
      </a>
    </li>
  </ul>

          </div>
        </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.ckx.ink/2021/10/08/201738.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://file.ckx.ink/upload/2020/04/android-chrome-512x512.png">
      <meta itemprop="name" content="开心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开心">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM内存结构 | 开心">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM内存结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-08 20:17:38" itemprop="dateCreated datePublished" datetime="2021-10-08T20:17:38+08:00">2021-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-07 17:29:25" itemprop="dateModified" datetime="2023-12-07T17:29:25+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>JVM内存结构</p>
</blockquote>
<span id="more"></span>

<p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行，JVM 内存结构规定了 java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行，不同的 JVM 对于内存的划分方式和管理机制存在着部分差异</p>
<p><img data-src="https://file.ckx.ink/upload/2021/11/up-6d8ce51d2963355c8d8cb86962b08cd7d12-ec27f2ce0a9c4cc0bcb5059590944d49.png" alt="image.png"></p>
<p>上图是 JVM 整体架构，中间部分就是 java 虚拟机定义的各种运行时数据区域</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>java 虚拟机栈（Java Virtual Machine Stacks），早期也叫 java 栈，每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次 java 方法调用，是线程私有的，生命周期和线程一致</p>
<p>作用：主导 java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回</p>
<p>特点：</p>
<ul>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈（进栈&#x2F;压栈），方法执行结束出栈</li>
<li>栈不存在垃圾回收问题</li>
</ul>
<p>可能出现的异常：</p>
<p>java 虚拟机规范允许 java 虚拟机栈的大小是动态的或者是固定不变的   </p>
<ul>
<li>如果采用固定大小的 java 虚拟机栈，那每个线程的 java 虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过 java 虚拟机栈允许的最大容量，java 虚拟机将会抛出一个 StackOverflowError 异常</li>
<li>如果 java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 java 虚拟机将会抛出一个 OutOfMemoryError 异常</li>
</ul>
<p>可以通过参数 -Xss 来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<h5 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h5><ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自有对应的一个栈帧</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h5 id="栈的运行原理"><a href="#栈的运行原理" class="headerlink" title="栈的运行原理"></a>栈的运行原理</h5><ul>
<li>JVM 直接对 java 栈的操作只有两个，对栈帧的压栈和出栈，遵循“先进后出&#x2F;后进先出”原则 </li>
<li>在一个活动线程中，一个时间点上，只会有一个活动的栈帧，即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）</li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧 </li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧 </li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>java 方法有两种返回函数的方式，一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出</li>
</ul>
<h5 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h5><ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）(或称为表达式栈)</li>
<li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ul>
<p><img data-src="https://file.ckx.ink/upload/2021/12/image-b29fd55537cc48c591df6f6d9127a1fa.png" alt="image.png"></p>
<h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><ul>
<li>局部变量表也被称为局部变量数组或者本地变量表</li>
<li>是一组变量值存储空间，主要用于存储方法参数和定义在方法体内的局部变量，包括编译器可知的各种 java 虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址，已被异常表取代）</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li>
<li>局部变量表所需要的容量大小是编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中，在方法运行期间是不会改变局部变量表的大小的</li>
<li>方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套调用次数越多，对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少，局部变量表中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
<li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束</li>
</ul>
<p>槽（Slot）：</p>
<ul>
<li>局部变量表最基本的存储单元是 Slot（变量槽）</li>
<li>在局部变量表中，32 位以内的类型只占用一个 Slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个连续的 Slot <ul>
<li>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true</li>
<li>long 和 double 则占据两个 Slot</li>
</ul>
</li>
<li>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 Slot 上</li>
<li>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）</li>
<li>如果当前帧是由构造方法或实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 Slot 处，其余的参数按照参数表顺序继续排列（这里就引出一个问题：静态方法中为什么不可以引用 this，就是因为 this 变量不存在于当前方法的局部变量表中）</li>
<li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的</li>
</ul>
<h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><ul>
<li>每个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称为表达式栈（Expression Stack） </li>
<li>操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop） </li>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈，比如，执行复制、交换、求和等操作</li>
<li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</li>
<li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，此时这个方法的操作数栈是空的 </li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 max_stack 数据项中</li>
<li>栈中的任何一个元素都可以是任意的 java 数据类型<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问 </li>
<li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令 </li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证 </li>
<li>另外，我们说 java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li>
</ul>
<p>栈顶缓存（Top-of-stack-Cashing）:</p>
<ul>
<li>HotSpot 的执行引擎采用的并非是基于寄存器的架构，但这并不代表 HotSpot VM 的实现并没有间接利用到寄存器资源，寄存器是物理 CPU 中的组成部分之一，它同时也是 CPU 中非常重要的高速存储资源，一般来说，寄存器的读&#x2F;写速度非常迅速，甚至可以比内存的读&#x2F;写速度快上几十倍不止，不过寄存器资源却非常有限，不同平台下的 CPU 寄存器数量是不同和不规律的，寄存器主要用于缓存本地机器指令、数值和下一条需要被执行的指令地址等数据</li>
<li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数，由于操作数是存储在内存中的，因此频繁的执行内存读&#x2F;写操作必然会影响执行速度，为了解决这个问题，HotSpot JVM 设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</li>
</ul>
<h6 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h6><p>指向运行时常量池的方法引用</p>
<ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）</li>
<li>在 java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 Class 文件的常量池中，比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li>
</ul>
<p><img data-src="https://file.ckx.ink/upload/2021/12/image-8307b672a03d4a92bc175ab6163b4b90.png" alt="image.png"></p>
<p>JVM 是如何执行方法调用的</p>
<p>方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程，Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用），也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用</p>
<p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关</p>
<ul>
<li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding），绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次</p>
<ul>
<li>早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用</li>
<li>晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定</li>
</ul>
<p>虚方法和非虚方法</p>
<ul>
<li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法 </li>
<li>其他方法称为虚方法</li>
</ul>
<p>虚方法表</p>
<ul>
<li>在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（Virtual Method Table），使用索引表来代替查找，非虚方法不会出现在表中</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</li>
<li>虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕</li>
</ul>
<h6 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h6><p>用来存放调用该方法的 PC 寄存器的值</p>
<p>一个方法的结束，有两种方式</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口<br>一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定<br>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口<br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li>
</ul>
<p>本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</p>
<h6 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h6><p>栈帧中还允许携带与 java 虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>简单的讲，一个 Native Method 就是一个 java 调用非 java 代码的接口，我们知道的 Unsafe 类就有很多本地方法</p>
<h5 id="为什么要使用本地方法"><a href="#为什么要使用本地方法" class="headerlink" title="为什么要使用本地方法"></a>为什么要使用本地方法</h5><ul>
<li>与 java 环境外交互：有时 java 应用需要与 java 外面的环境交互，这就是本地方法存在的原因</li>
<li>与操作系统交互：JVM 支持 java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持，通过本地方法，我们可以实现用 java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的</li>
<li>Sun’s Java：Sun 的解释器就是 C 实现的，这使得它能像一些普通的 C 一样与外部交互，jre 大部分都是用 java 实现的，它也通过一些本地方法与外界交互，比如，类 java.lang.Thread 的 setPriority() 的方法是用 java 实现的，但它实现调用的是该类的本地方法 setPrioruty()，该方法是 C 实现的，并被植入 JVM 内部</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数寄存器（Program Counter Register），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行</p>
<p>这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会，JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</p>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，由执行引擎读取下一条指令，</p>
<p>分析：进入 class 文件所在目录，执行 javap -v xx.class 反解析（或者通过 IDEA 插件 Jclasslib 直接查看），可以看到当前类对应的 Code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等信息</p>
<h5 id="使用-PC-寄存器存储字节码指令地址有什么用"><a href="#使用-PC-寄存器存储字节码指令地址有什么用" class="headerlink" title="使用 PC 寄存器存储字节码指令地址有什么用"></a>使用 PC 寄存器存储字节码指令地址有什么用</h5><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行，JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令</p>
<h5 id="PC-寄存器为什么会被设定为线程私有的"><a href="#PC-寄存器为什么会被设定为线程私有的" class="headerlink" title="PC 寄存器为什么会被设定为线程私有的"></a>PC 寄存器为什么会被设定为线程私有的</h5><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU 会不停的做任务切换，这样必然会导致经常中断或恢复，为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个 PC 寄存器，每个线程都独立计算，不会互相影响</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域 </li>
<li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法，如果当前线程正在执行的是 java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）</li>
<li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><h5 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h5><p>对于大多数应用，java 堆是 java 虚拟机管理的内存中最大的一块，被所有线程共享，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p>
<ul>
<li>新生代（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间（JDK8 之前叫永久代）：像一些方法中的操作临时对象等，JDK8 之前是占用 JVM 内存，JDK8 之后直接使用物理内存</li>
</ul>
<p><img data-src="https://file.ckx.ink/upload/2021/12/image-f73e3ecec3e440269e84ab71abe8f69b.png" alt="image.png"></p>
<p>java 虚拟机规范规定，java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样，实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常</p>
<h6 id="年轻代（Young-Generation）"><a href="#年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h6><p>年轻代是所有新对象创建的地方，在年轻代执行的垃圾收集被称为 Minor GC，年轻代默认被分为一个 Eden 和两个 Survivor，默认比例是 8:1:1</p>
<ul>
<li>新对象先放在 Eden 区，此区有大小限制</li>
<li>当 Eden 区的空间已经满了或放不下了，程序又需要创建对象，会触发 Minor GC</li>
<li>然后将 Eden 区的存活对象移动到 From Survivor 区</li>
<li>之后创建的对象会继续分配在 Eden 区，当 Eden 区又满了或放不下了，这时候将会把 Eden 区和 From Survivor 区的存活对象移动到 To Survivor 区</li>
<li>回收 Eden 区和 From 区的所有内存，然后反转 From Survivor 和 To Survivor 的功能</li>
<li>经历过默认 15 次垃圾回收的对象将会放到老年代</li>
</ul>
<p>空间分配担保：</p>
<p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的，如果不成立，则虚拟机会查看 HandlerPromotionFailure（true，false）是否允许担保失败，如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的，如果小于，或者 HandlerPromotionFailure 为 false，那么这次 Minor GC 将升级为 Full GC</p>
<h6 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h6><p>老年代主要存放大对象或者生命周期较长的对象，老年代的垃圾收集称为 Major GC，通常需要更长的时间</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝</p>
<p>年轻代如何进入到老年代：</p>
<ul>
<li>Minor GC 时发现存活的对象在 To Survivor 区中存不下，那么把存活的对象存入老年代</li>
<li>如果对象较大，则直接进入老年代，通过 -XX:PretenureSizeThreshold 设置</li>
<li>长期存活的对象将进入老年代，默认是 15，通过 -XX:MaxTenuringThreshold 来设置</li>
<li>动态对象年龄判定，如果在 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代</li>
</ul>
<p><img data-src="https://file.ckx.ink/upload/2021/12/image-e3cdc70cf8734cbdabae985ab933780a.png" alt="image.png"></p>
<h6 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h6><p>不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 java 虚拟机规范中方法区的实现</p>
<p>虽然 java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 java 堆区分开</p>
<p>所以元空间放在后边的方法区再说</p>
<h5 id="设置堆内存的参数"><a href="#设置堆内存的参数" class="headerlink" title="设置堆内存的参数"></a>设置堆内存的参数</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xmx # 设置最大可用堆内存</span><br><span class="line">-Xms # 设置初始堆大小</span><br><span class="line">-Xmn # 设置年轻代堆大小</span><br><span class="line">-Xss # 设置每个线程的堆栈大小</span><br><span class="line">-XX:NewSize # 设置年轻代最小空间大小</span><br><span class="line">-XX:MaxNewSize # 设置年轻代最大空间大小</span><br><span class="line">-XX:PermSize # 设置永久代最小空间大小</span><br><span class="line">-XX:MaxPermSize # 设置永久代最大空间大小</span><br><span class="line">-XX:NewRatio # 设置年轻代与老年代的比值，如设置为 4 ，则年轻代与老年代所占比值为 1:4，年轻代占整个堆栈的 1/5</span><br><span class="line">-XX:SurvivorRatio # 设置年轻代中 Eden 区与 Survivor 区的大小比值，如设置为 4，则两个 Survivor 区与一个 Eden 区的比值为 2:4，一个 Survivor 区占整个年轻代的 1/6</span><br></pre></td></tr></table></figure>

<p>如果堆的内存大小超过 -Xmx 设定的最大内存， 就会抛出 OutOfMemoryError 异常</p>
<p>我们通常会将 -Xmx 和 -Xms 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能</p>
<ul>
<li>默认情况下，初始堆内存大小为：电脑内存大小 &#x2F; 64</li>
<li>默认情况下，最大堆内存大小为：电脑内存大小 &#x2F; 4</li>
</ul>
<p>可以通过代码获取到我们的设置值，当然也可以模拟 OOM：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">  // 返回 JVM 堆大小</span><br><span class="line">  long initMemory = Runtime.getRuntime().totalMemory() / 1024 /1024;</span><br><span class="line">  // 返回 JVM 堆的最大内存</span><br><span class="line">  long maxMemory = Runtime.getRuntime().maxMemory() / 1024 /1024;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;-Xms : &quot; + initMemory + &quot;M&quot;);</span><br><span class="line">  System.out.println(&quot;-Xmx : &quot; + maxMemory + &quot;M&quot;);</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;系统内存大小：&quot; + initMemory * 64 / 1024 + &quot;G&quot;);</span><br><span class="line">  System.out.println(&quot;系统内存大小：&quot; + maxMemory * 4 / 1024 + &quot;G&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="查看堆内存分配"><a href="#查看堆内存分配" class="headerlink" title="查看堆内存分配"></a>查看堆内存分配</h6><ul>
<li>在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小</li>
<li>默认情况下新生代和老年代的比例是 1:2，可以通过 –XX:NewRatio 来配置<ul>
<li>新生代中的 Eden : From Survivor : To Survivor 的比例是 8:1:1，可以通过 -XX:SurvivorRatio 来配置</li>
</ul>
</li>
<li>若在 JDK7 中开启了 -XX:+UseAdaptiveSizePolicy，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄<ul>
<li>此时 –XX:NewRatio 和 -XX:SurvivorRatio  将会失效，而 JDK8 是默认开启 -XX:+UseAdaptiveSizePolicy</li>
<li>在 JDK8 中，不要随意关闭 -XX:+UseAdaptiveSizePolicy，除非对堆内存的划分有明确的规划</li>
</ul>
</li>
</ul>
<p>每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小<br>计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep HeapSize</span><br><span class="line">    uintx ErgoHeapSizeLimit                         = 0                                   &#123;product&#125;</span><br><span class="line">    uintx HeapSizePerGCThread                       = 87241520                            &#123;product&#125;</span><br><span class="line">    uintx InitialHeapSize                          := 134217728                           &#123;product&#125;</span><br><span class="line">    uintx LargePageHeapSizeThreshold                = 134217728                           &#123;product&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 2147483648                          &#123;product&#125;</span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程号</span><br></pre></td></tr></table></figure>

<h5 id="垃圾回收简介"><a href="#垃圾回收简介" class="headerlink" title="垃圾回收简介"></a>垃圾回收简介</h5><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代</p>
<p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）</p>
<ul>
<li>部分收集：不是完整收集整个堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li>
<li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集<ul>
<li>目前，只有 CMS GC 会有单独收集老年代的行为</li>
<li>很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个堆和方法区的垃圾</li>
</ul>
<h6 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h6><ul>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>要晋升到老年代的的对象所占用的空间大于老年代的剩余空间</li>
<li>显示调用 System.gc()<ul>
<li>建议垃圾回收器执行垃圾回收，但是不必然执行</li>
<li>-XX:+DisableExplicitGC 参数，忽略掉 System.gc() 的调用</li>
</ul>
</li>
</ul>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p>什么是 TLAB （Thread Local Allocation Buffer）?</p>
<ul>
<li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li>
<li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为快速分配策略</li>
<li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li>
</ul>
<h6 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 TLAB ?</h6><ul>
<li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选</p>
<p>在程序中，可以通过 -XX:UseTLAB 设置是否开启 TLAB 空间</p>
<p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 -XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小</p>
<p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>方法区（Method Area）与堆一样，是所有线程共享的内存区域，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与堆区分开</li>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分，Class 文件中除了有类的版本&#x2F;字段&#x2F;方法&#x2F;接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 String.intern()方法，受方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常</li>
<li>方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误</li>
<li>JVM 关闭后方法区即被释放</li>
</ul>
<h5 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h5><p>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等，</p>
<h6 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h6><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public、abstract、final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h6 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h6><ul>
<li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集</li>
</ul>
<h6 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h6><p>JVM 必须保存所有方法的</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型</li>
<li>方法参数的数量和类型</li>
<li>方法的修饰符（public、private、protected、static、final、synchronized、native、abstract 的一个子集） 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li>
<li>异常表（abstract 和 native 方法除外）<ul>
<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
<h6 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h6><p><img data-src="https://file.ckx.ink/upload/2021/12/image-029d13727a7c4d159b84030dd495c209.png" alt="image.png"></p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p>
<h6 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h6><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用</p>
<h6 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h6><p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件，而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在动态链接的时候用到的就是运行时常量池</p>
<h6 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><ul>
<li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li>
<li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>
<li>JVM 为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的 </li>
<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用，此时不再是常量池中的符号地址了，这里换为真实地址<ul>
<li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的</li>
</ul>
</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常</li>
</ul>
<h5 id="方法区在-JDK-中的演进细节"><a href="#方法区在-JDK-中的演进细节" class="headerlink" title="方法区在 JDK 中的演进细节"></a>方法区在 JDK 中的演进细节</h5><p>只有 HotSpot 才有永久代的概念</p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jdk6及之前</td>
<td align="center">有永久代，静态变量存放在永久代上</td>
</tr>
<tr>
<td align="center">jdk7</td>
<td align="center">有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td>
</tr>
<tr>
<td align="center">jdk8及之后</td>
<td align="center">取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>开心
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.ckx.ink/2021/10/08/201738.html" title="JVM内存结构">https://blog.ckx.ink/2021/10/08/201738.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/20/202133.html" rel="prev" title="MongoDB时间字段比较">
                  <i class="fa fa-chevron-left"></i> MongoDB时间字段比较
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/08/220207.html" rel="next" title="Java内存模型">
                  Java内存模型 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81ODIwNS8zNDY2OA=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备20013274号-1 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">开心</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">100k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:02</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/chenkaixin12121" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="/lib/jquery/dist/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="/lib/pangu/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="/lib/quicklink/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.ckx.ink/2021/10/08/201738.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
